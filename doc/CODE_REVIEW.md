# コードレビュー報告書

**レビュー日**: 2025-12-07  
**対象**: 勤怠管理システム全体

---

## 📋 概要

本ドキュメントは、勤怠管理システムのコードベース全体をレビューした結果をまとめたものです。セキュリティ、パフォーマンス、コード品質、アーキテクチャの観点から気になる箇所を指摘しています。

---

## 🔴 重要度: 高（早急に対応すべき）

### 1. セキュリティ - CORS設定が緩すぎる

**ファイル**: `backend/public/api.php`（21行目）

```php
header('Access-Control-Allow-Origin: *');
```

**問題点**:
- `*`（ワイルドカード）を使用しており、すべてのオリジンからのアクセスを許可している
- 本番環境では、悪意のあるサイトからのクロスサイトリクエストを許可してしまう
- 認証情報（Cookie）を含むリクエストとの組み合わせでセキュリティリスクが高まる

**推奨対応**:
```php
// 本番環境では許可するオリジンを明示的に指定
$allowedOrigins = ['https://yourdomain.com', 'https://app.yourdomain.com'];
$origin = $_SERVER['HTTP_ORIGIN'] ?? '';
if (in_array($origin, $allowedOrigins)) {
    header('Access-Control-Allow-Origin: ' . $origin);
    header('Access-Control-Allow-Credentials: true');
}
```

**[初心者向け解説]**
- **CORSとは？**: "Cross-Origin Resource Sharing" の略で、直訳すると「オリジンをまたいだリソース共有」です。Webページ（例: `https://example.com`）が、それとは異なるドメインのサーバー（例: `https://api.example.com`）にデータを要求する際に、ブラウザが安全のために設けているセキュリティルールです。
- **`*` が危険な理由**: `*` は「どのサイトからでもアクセスOK」という非常に緩い設定です。これにより、悪意のある人が作った偽サイト（例: `https://evil-site.com`）からあなたのAPIが呼び出され、データを盗まれたり、不正な操作をされたりする危険性があります。
- **推奨対応の意味**: このコードは、まず自分たちが信頼するWebサイトのリスト（`$allowedOrigins`）を定義します。そして、リクエストを送ってきたサイトのURL（`$origin`）がそのリストに含まれている場合だけ、アクセスを許可するようにしています。これにより、信頼できるサイトだけがAPIと通信できるようになります。

---

### 2. セキュリティ - パスワードリセットトークンがレスポンスに含まれている

**ファイル**: `backend/src/Controllers/AuthController.php`（386-389行目）

```php
// TODO: メール送信機能を実装
// 開発環境ではトークンをレスポンスに含める（本番環境では削除）
$response->success([
    'token' => $token, // 開発環境のみ
    'expires_at' => $expiresAt,
], 'パスワードリセットメールを送信しました');
```

**問題点**:
- パスワードリセットトークンがAPIレスポンスに含まれている
- 本番環境でこのコードが残っていると、攻撃者がトークンを取得できてしまう
- コメントで「本番環境では削除」と記載されているが、環境チェックが実装されていない

**推奨対応**:
```php
// 環境変数で制御
if ($_ENV['APP_ENV'] === 'development' && ($_ENV['APP_DEBUG'] ?? false)) {
    $response->success([
        'token' => $token,
        'expires_at' => $expiresAt,
    ], 'パスワードリセットメールを送信しました');
} else {
    $response->success(null, 'パスワードリセットメールを送信しました');
}
```

**[初心者向け解説]**
- **トークンとは？**: ここで言うトークンは、パスワードをリセットする権利を持つ人だけが知っている「一時的な合言葉」のようなものです。通常はメールで本人にだけ送られます。
- **なぜ危険か？**: この「合言葉」がAPIの応答メッセージに含まれていると、開発ツールのネットワークタブなどから誰でも見えてしまいます。攻撃者がこれを知ると、本人になりすましてパスワードを勝手に変更できてしまいます。
- **推奨対応の意味**: `$_ENV['APP_ENV']` は、現在の動作環境（開発環境か、本番環境か）を示す設定値です。このコードは「もし開発環境（`development`）なら、デバッグのためにトークンを画面に表示してもよい。しかし、それ以外（本番環境など）の場合は、トークンは表示せず、メール送信の成功メッセージだけを返す」という条件分岐を加えています。これにより、本番環境での情報漏洩を防ぎます。

---

### 3. セキュリティ - エラーメッセージに詳細情報が含まれている

**ファイル**: `backend/src/Controllers/AuthController.php`（312行目）

```php
$response->error('INTERNAL_ERROR', '会員登録に失敗しました: ' . $e->getMessage(), [], 500);
```

**問題点**:
- 例外メッセージがそのままクライアントに返されている
- データベースエラーやシステム内部の情報が漏洩する可能性がある
- 同様のパターンが複数のコントローラーに存在

**影響ファイル**:
- `AuthController.php`（312行目、614行目、718行目）
- `PunchController.php`（170行目、173行目、357行目、360行目）

**推奨対応**:
```php
// 本番環境ではエラー詳細を隠蔽
if ($_ENV['APP_ENV'] === 'production') {
    error_log('会員登録エラー: ' . $e->getMessage()); // ログには記録
    $response->error('INTERNAL_ERROR', '会員登録に失敗しました', [], 500);
} else {
    $response->error('INTERNAL_ERROR', '会員登録に失敗しました: ' . $e->getMessage(), [], 500);
}
```

**[初心者向け解説]**
- **なぜ危険か？**: プログラムの内部エラーメッセージ（`$e->getMessage()`）には、「データベースの〇〇テーブルに接続できません」や「ファイル`/path/to/secret/file.php`が見つかりません」といった、システムの構造に関する情報が含まれていることがあります。これらの情報を攻撃者に与えることは、家の設計図を泥棒に渡すようなもので、攻撃のヒントを与えてしまいます。
- **推奨対応の意味**: 「もし本番環境（`production`）なら、ユーザーには単に『失敗しました』というシンプルなメッセージだけを見せる。その代わり、エラーの詳しい内容は開発者だけが見られるログファイル（`error_log`）に記録する」という方針です。これにより、ユーザーには余計な情報を見せずに安全を保ちつつ、開発者は問題の原因を調査できるようになります。

---

### 4. セキュリティ - デバッグ設定が有効

**ファイル**: `backend/public/api.php`（7-8行目）

```php
error_reporting(E_ALL);
ini_set('display_errors', '1');
```

**問題点**:
- エラー表示が常に有効になっている
- 本番環境でスタックトレースやシステム情報が表示される可能性がある

**推奨対応**:
```php
if ($_ENV['APP_ENV'] === 'production') {
    error_reporting(0);
    ini_set('display_errors', '0');
} else {
    error_reporting(E_ALL);
    ini_set('display_errors', '1');
}
```

**[初心者向け解説]**
- **何をしている設定か？**: `error_reporting(E_ALL)`は「すべての種類のエラーを報告する」、`ini_set('display_errors', '1')`は「報告されたエラーを画面に表示する」という設定です。これらは開発中には非常に便利ですが、本番環境で有効になっていると問題です。
- **なぜ危険か？**: 予期せぬエラーが発生した際に、PHPはエラーの詳細情報（どのファイルの何行目で、どのような関数呼び出しの最中にエラーが起きたかなど）を画面全体に表示してしまいます。これは先の「エラーメッセージに詳細情報が含まれている」問題と同様に、攻撃者にシステムの内部情報を与えてしまうことになり、非常に危険です。
- **推奨対応の意味**: ここでも環境変数を使って、「本番環境ではエラーを画面に一切表示しない設定に、開発環境ではすべてのエラーを表示する設定にする」という切り替えを自動的に行っています。

---

## 🟠 重要度: 中（計画的に対応すべき）

### 5. アーキテクチャ - データベース接続のシングルトンパターン

**ファイル**: `backend/src/Core/Database.php`

**問題点**:
- シングルトンパターンを使用しているが、テスト時のモック化が困難
- 依存性注入（DI）パターンを使用していないため、単体テストが書きにくい

**推奨対応**:
- 将来的にDIコンテナの導入を検討
- または、コンストラクタインジェクションに変更

**[初心者向け解説]**
- **シングルトンパターンとは？**: オブジェクト（ここではデータベース接続）がアプリケーション全体で絶対に1つしか作られないことを保証する設計パターンです。便利ですが、どこからでも直接呼び出せるため、依存関係が隠れやすくなります。
- **テストが困難な理由**: テストを書くとき、本物のデータベースに接続する代わりに、偽のデータベース（モック）に差し替えてテストしたい場合があります（例: テストのたびにDBを汚さないため）。しかし、シングルトンだとこの「差し替え」が非常に難しくなります。
- **依存性注入（DI）とは？**: クラスが必要とするオブジェクト（依存物）を、クラスの外部から与える（注入する）設計手法です。例えば、`new Controller(new Database())`のように、コンストラクタ経由で渡すのが一般的です（コンストラクタインジェクション）。DIを使うと、テスト時には`new Controller(new MockDatabase())`のように、偽のオブジェクトを簡単に注入でき、テストがずっと楽になります。

---

### 6. コード品質 - TODOコメントが放置されている

**影響ファイル**:
- `DashboardController.php`（139行目、342行目）: `// TODO: 部署階層を考慮`
- `EmployeeController.php`（37行目）: `// TODO: 部署階層を考慮した配下従業員の取得`
- `RequestController.php`（383行目、510行目）: `// TODO: 部署階層を考慮した配下従業員のチェック`
- `PunchController.php`（262行目）: `// TODO: 部署階層を考慮した配下従業員のチェック`
- `AuthController.php`（384行目）: `// TODO: メール送信機能を実装`

**問題点**:
- 部署階層の考慮が未実装のため、Managerロールの権限チェックが不完全
- 現在は「全従業員を許可」というコメントがあり、セキュリティ上の懸念がある

**推奨対応**:
- TODOをIssueトラッカーに登録して追跡
- 優先度を付けて計画的に実装

**[初心者向け解説]**
- **TODOコメントとは？**: 「後でやるべきこと」をメモとしてコード内に残すためのコメントです。
- **なぜ問題か？**: TODOは便利なメモですが、放置されると「技術的負債」となります。このケースでは、「部署の階層を考慮したチェック」という重要な機能が未実装のまま放置されています。その結果、「本来は見られないはずの他部署の情報が見えてしまう」といったセキュリティ上の欠陥（バグ）に繋がっています。
- **推奨対応の意味**: コード内のTODOは見過ごされやすいため、GitHubのIssuesやJiraのような課題管理ツール（Issueトラッカー）に正式なタスクとして登録し、誰がいつまでに対応するのかを明確にしましょう、ということです。

---

### 7. フロントエンド - ハードコードされたAPIベースURL

**ファイル**: `scripts/common.js`（201行目）、`index.html`（81行目）

```javascript
const API_BASE_URL = 'http://localhost:8080/api.php';
```

**問題点**:
- 開発環境のURLがハードコードされている
- 本番環境へのデプロイ時に変更が必要
- 環境ごとの設定管理が困難

**推奨対応**:
```javascript
// 環境変数または設定ファイルから読み込む
const API_BASE_URL = window.APP_CONFIG?.API_BASE_URL || 'http://localhost:8080/api.php';
```

**[初心者向け解説]**
- **ハードコードとは？**: プログラムの中に、後で変更される可能性のある設定値（この場合はAPIサーバーのURL）を直接書き込んでしまうことです。
- **なぜ問題か？**: 自分のPC（開発環境）では `http://localhost:8080` で動きますが、インターネット上の本番環境では `https://api.example.com` のようにURLが変わります。ハードコードされていると、本番環境にデプロイするたびにこのURLをいちいち手で書き換える必要があり、非常に面倒で、間違いのもとになります。
- **推奨対応の意味**: URLのような環境によって変わる値は、設定ファイルや環境変数として外出しにし、プログラムはそれを読み込むだけにします。これにより、コード自体を一切変更することなく、設定を変えるだけでどの環境にも対応できるようになります。

---

### 8. セキュリティ - セッションIDがレスポンスに含まれている

**ファイル**: `backend/src/Controllers/AuthController.php`（90-91行目）

```php
$response->success([
    'user' => [...],
    'session_id' => session_id(),
], 'ログインに成功しました');
```

**問題点**:
- セッションIDをAPIレスポンスに含めることは推奨されない
- セッションIDはHTTP Onlyクッキーで管理すべき

**推奨対応**:
- `session_id`をレスポンスから削除
- セッション管理はクッキーのみで行う

**[初心者向け解説]**
- **セッションIDとは？**: ログイン状態を維持するための「整理券」のようなものです。ユーザーがログインするとサーバーがこのIDを発行し、以降の通信でブラウザがこのIDを送ることで、サーバーは「ああ、あの人だな」と認識します。
- **なぜ危険か？**: この「整理券」をAPIの応答メッセージに含めると、JavaScriptから読み取れてしまいます。もしサイトにXSS（クロスサイトスクリプティング）という脆弱性があった場合、攻撃者が仕込んだスクリプトによってセッションIDが盗まれ、アカウントが乗っ取られてしまう危険性があります。
- **推奨対応の意味**: セッションIDは、`HttpOnly`という特別な属性を付けたCookieでブラウザに保存するのが最も安全な方法です。`HttpOnly`属性が付いていると、JavaScriptからそのCookieを読み取ることができなくなるため、XSS攻撃によるセッションIDの盗難を防ぐことができます。

---

### 9. パフォーマンス - N+1クエリの可能性

**ファイル**: `backend/src/Controllers/DashboardController.php`

**問題点**:
- 従業員一覧を取得後、各従業員に対して個別にクエリを発行している可能性がある
- 大規模なテナントでパフォーマンス問題が発生する可能性

**推奨対応**:
- JOINやサブクエリを使用して1回のクエリで取得
- キャッシュの導入を検討

**[初心者向け解説]**
- **N+1クエリ問題とは？**: データベースへの問い合わせ（クエリ）が非効率になる典型的なパターンです。例えば、「10人（N=10）の従業員リストを取得し（1回のクエリ）、その後、ループ処理で各従業員の所属部署を1人ずつ問い合わせる（N=10回のクエリ）」という処理をすると、合計で N+1回 (11回) のクエリが発生します。従業員が1000人いれば1001回もデータベースと通信することになり、非常に遅くなります。
- **推奨対応の意味**: `JOIN`というSQLの機能を使えば、「従業員テーブルと部署テーブルを内部的に結合し、1回のクエリで従業員とその所属部署の情報をまとめて取得する」ことができます。これにより、データベースとの通信が1回で済み、パフォーマンスが劇的に改善します。

---

### 10. コード品質 - 重複コード

**影響ファイル**: `AuthController.php`

**問題点**:
- 役割取得のSQLクエリが複数箇所で重複している（51-66行目、132-147行目、583-598行目）

```php
$stmt = $pdo->prepare("
    SELECT r.tenant_id, r.role
    FROM role_assignments r
    WHERE r.user_id = :user_id AND r.deleted_at IS NULL
    ORDER BY 
        CASE r.role
            WHEN 'SystemAdmin' THEN 1
            WHEN 'CompanyAdmin' THEN 2
            ...
        END
    LIMIT 1
");
```

**推奨対応**:
- 共通のメソッドまたはリポジトリクラスに抽出

**[初心者向け解説]**
- **重複コードの問題点**: 同じようなコードが複数の場所にコピペされていると、いくつかの問題が発生します。
    1.  **修正が大変**: 仕様変更でこのSQLを直す必要が出たとき、すべての場所を忘れずに修正しなければならず、漏れが生じやすいです。
    2.  **バグの温床**: ある場所では修正したのに、別の場所では修正し忘れた、といったことが起こり、不整合やバグの原因になります。
    3.  **可読性の低下**: ファイルが不必要に長くなり、コードが読みにくくなります。
- **推奨対応の意味**: このような共通の処理は、1つの関数（メソッド）として独立させ、必要な場所からその関数を呼び出すように変更します。これを「共通化」や「リファクタリング」と呼びます。そうすれば、修正が必要になったときもその関数を1ヶ所直すだけで済み、保守性が格段に向上します。

---

## 🟡 重要度: 低（改善推奨）

### 11. ドキュメント - README.mdのリンク切れ

**ファイル**: `README.md`

**問題点**:
- `GITHUB_SETUP.md`への参照があるが、ファイルが存在しない
- `PROJECT_STATUS.md`でも指摘されている

**推奨対応**:
- 該当の参照を削除するか、ファイルを作成

**[初心者向け解説]**
- **README.mdとは？**: プロジェクトの玄関口となる説明ファイルです。新しいメンバーがプロジェクトに参加したとき、まず最初にこのファイルを読みます。
- **なぜ問題か？**: この玄関口に書かれている情報が古かったり、リンクが切れていたりすると、プロジェクトの第一印象が悪くなるだけでなく、セットアップでつまずくなど、新しいメンバーの生産性を下げてしまいます。ドキュメントはコードと同じように、常に最新の状態に保つことが重要です。

---

### 12. フロントエンド - console.debugの使用

**ファイル**: `scripts/common.js`（33行目、91-93行目、796行目）

**問題点**:
- デバッグ用のconsole文が残っている
- 本番環境ではコンソール出力を最小限にすべき

**推奨対応**:
- ビルドプロセスでconsole文を削除
- または、環境変数でログレベルを制御

**[初心者向け解説]**
- **`console.debug`とは？**: 開発者がプログラムの動作を確認するために、ブラウザの開発者コンソールに変数の値などを表示させる命令です。
- **なぜ問題か？**: 開発中は便利ですが、本番環境でこれが残っていると、一般のユーザーでも開発者コンソールを開けば内部のデータや動作が見えてしまう可能性があります。直接的なセキュリティリスクは低いことが多いですが、システムの内部情報が漏れることにも繋がりかねませんし、プロフェッショナルな作法とはいえません。
- **推奨対応の意味**: 本番用のファイルを作成する際（ビルドプロセス）に、これらの`console`文を自動的に削除するツールを導入するのが一般的です。

---

### 13. データベース - パスワードリセットトークンの制約重複

**ファイル**: `database/schema.sql`（62-63行目）

```sql
CONSTRAINT password_reset_tokens_token_unique UNIQUE (token)
```

**問題点**:
- `token`カラムに`UNIQUE`制約が2回定義されている（58行目と62行目）

**推奨対応**:
- 重複する制約を削除

**[初心者向け解説]**
- **UNIQUE制約とは？**: データベースのテーブルで、特定の列（カラム）に重複した値が入らないようにするためのルールです。例えば、ユーザーIDやメールアドレスが他の人と被らないように設定します。
- **なぜ問題か？**: この場合、`token`列に対して同じルールが2回設定されています。プログラムの動作自体に影響はないかもしれませんが、無駄な定義であり、後からテーブルの設計を見た人が「なぜ2つあるんだろう？何か特別な意味があるのかな？」と混乱する原因になります。不要なものは削除して、シンプルで分かりやすい状態を保つべきです。

---

### 14. フロントエンド - ローカルストレージへのユーザー情報保存

**ファイル**: `index.html`（116-118行目）

```javascript
if (data.data && data.data.user) {
    localStorage.setItem('user', JSON.stringify(data.data.user));
}
```

**問題点**:
- ユーザー情報をlocalStorageに保存している
- XSS攻撃時にユーザー情報が漏洩する可能性
- セッション管理はサーバーサイドで行うべき

**推奨対応**:
- 必要最小限の情報のみ保存（例：ユーザー名のみ）
- 機密情報はセッションで管理

**[初心者向け解説]**
- **localStorageとは？**: ブラウザにデータを保存できる簡単な仕組みです。手軽ですが、JavaScriptから簡単に読み書きできるため、セキュリティには注意が必要です。
- **なぜ危険か？**: もしサイトにXSS（クロスサイトスクリプティング）の脆弱性があると、攻撃者が仕込んだスクリプトによって`localStorage`に保存されているデータがすべて盗まれてしまいます。ここにユーザーの個人情報や権限情報などを保存していると、情報漏洩に直結します。
- **推奨対応の意味**: `localStorage`に保存するのは、盗まれても被害が少ない情報（例: ユーザー名など）に限定し、パスワードやセッションIDのような機密情報は保存すべきではありません。ログイン状態の管理は、サーバーサイドのセッションと、JavaScriptから読み取れない`HttpOnly`属性付きのCookieで行うのが安全です。

---

### 15. コード品質 - マジックナンバー/文字列

**影響ファイル**: 複数のコントローラー

**問題点**:
- ロール名（'SystemAdmin', 'CompanyAdmin'等）が文字列リテラルで散在
- ステータス値（'active', 'pending'等）も同様

**推奨対応**:
- 定数クラスまたはEnumを定義して一元管理

```php
class Role {
    const SYSTEM_ADMIN = 'SystemAdmin';
    const COMPANY_ADMIN = 'CompanyAdmin';
    const PROFESSIONAL = 'Professional';
    const MANAGER = 'Manager';
    const EMPLOYEE = 'Employee';
}
```

**[初心者向け解説]**
- **マジックナンバー/文字列とは？**: `if ($role === 'SystemAdmin')` のように、コードの中に直接書かれた、一見しただけでは意味が分かりにくい数値や文字列のことです。
- **なぜ問題か？**:
    1.  **可読性の低下**: `'SystemAdmin'`という文字列が何を表すのか、そのコードだけでは分かりにくい場合があります。
    2.  **変更が困難**: もしロール名を`'SystemAdministrator'`に変更したくなった場合、コードの中から`'SystemAdmin'`と書かれている箇所をすべて探し出して修正する必要があり、修正漏れのリスクが高まります。
    3.  **タイポの危険**: `if ($role === 'SystemAdmn')` のように打ち間違えても、プログラムはエラーにならず、ただ期待通りに動かないという発見しづらいバグになります。
- **推奨対応の意味**: `Role::SYSTEM_ADMIN`のように、意味のある名前を付けた「定数」として定義し、それを使うようにします。こうすることで、コードが読みやすくなり、タイポすればエラーが出るためバグに気づきやすく、ロール名を変更したくなった場合も定数の定義を1ヶ所変えるだけで済むようになります。

---

## 📊 レビューサマリー

| 重要度 | 件数 | 主な内容 |
|--------|------|----------|
| 🔴 高 | 4件 | セキュリティ関連（CORS、トークン露出、エラー情報漏洩、デバッグ設定） |
| 🟠 中 | 6件 | アーキテクチャ、コード品質、パフォーマンス |
| 🟡 低 | 5件 | ドキュメント、コード整理、ベストプラクティス |

---

## ✅ 良い点

1. **データベース設計**
   - Row-Level Security (RLS)を考慮した設計
   - 適切なインデックス設定
   - 循環参照防止のトリガー実装

2. **認証・認可**
   - bcryptによるパスワードハッシュ化
   - パスワードポリシーの実装（最小8文字、大文字・小文字・数字・記号）
   - レート制限の実装（パスワードリセット）

3. **コード構成**
   - MVC的なディレクトリ構造
   - ミドルウェアパターンの採用
   - 監査ログの実装

4. **API設計**
   - RESTfulなエンドポイント設計
   - 適切なHTTPステータスコードの使用
   - ページネーション対応

---

## 🎯 推奨アクションプラン

### Phase 1: 緊急対応
1. CORS設定の修正
2. パスワードリセットトークンのレスポンス除外
3. エラーメッセージの詳細情報隠蔽
4. デバッグ設定の環境変数化

### Phase 2: 計画的改善
1. TODOコメントの対応（部署階層考慮）
2. APIベースURLの設定ファイル化
3. 重複コードのリファクタリング

### Phase 3: 継続的改善
1. 単体テストの追加
2. DIコンテナの導入検討
3. パフォーマンス最適化

---

**レビュー担当**: AI Code Review  
**最終更新**: 2025-12-07

---

## 初心者向け注釈

### Phase 1: 緊急対応
- CORS設定の修正: 許可するURLをリストで書き、`Access-Control-Allow-Origin`にそのURLだけを返すようにする（`*`は使わない）。
- パスワードリセットトークンのレスポンス除外: 本番ではトークンをAPIレスポンスに入れない。開発用フラグ（例: `APP_ENV=development`）で分ける。
- エラーメッセージの詳細情報隠蔽: 本番では利用者に内部のエラー詳細を見せず、ログにだけ記録する。
- デバッグ設定の環境変数化: `display_errors`や`error_reporting`を環境ごとに切り替える。`.env`の`APP_ENV`で判定するのが手軽。

### Phase 2: 計画的改善
- TODOコメントの対応（部署階層考慮）: 役職や部署の階層ロジックを実装し、権限チェックが正しく効くようにする。Issue化して順番を決める。
- APIベースURLの設定ファイル化: `API_BASE_URL`を設定ファイルや環境変数から読むようにし、環境ごとに書き換えなくて済むようにする。
- 重複コードのリファクタリング: 同じSQLや処理は共通メソッドにまとめて、修正漏れや不整合を防ぐ。

### Phase 3: 継続的改善
- 単体テストの追加: コントローラーやモデルを対象に、主要なパス（成功/失敗/権限エラー）をテストする。DIを意識するとモックが作りやすい。
- DIコンテナの導入検討: 依存関係をコンテナで管理し、テスト時に差し替えられるようにする。小さく始めて徐々に適用範囲を広げる。
- パフォーマンス最適化: N+1対策（JOINやまとめ取得）、キャッシュ導入、ログを見たボトルネック解消を継続的に行う。
